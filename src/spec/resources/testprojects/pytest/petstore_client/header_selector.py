# coding: utf-8

"""
Swagger Petstore - OpenAPI 3.0

A simplified Pet Store API for integration testing.

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
Generator version: 7.14.0
"""

"""
NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
https://openapi-generator.tech
Do not edit the class manually.
"""

import re
import math
from typing import Dict, List, Optional, Tuple


class HeaderSelector:
    """HeaderSelector"""

    _JSON_MIME_PATTERN = re.compile(
        r'^application/(json|[\w!#$&.+\-^_]+\+json)\s*(;|$)',
        re.IGNORECASE
    )

    _WEIGHT_PATTERN = re.compile(r'(.*)\s*;\s*q=(1(?:\.0+)?|0\.\d+)$')

    def select_headers(
        self,
        accept: List[str],
        content_type: str,
        is_multipart: bool
    ) -> Dict[str, str]:
        """Select headers for an API request.

        :param accept: array of acceptable MIME types for the response
        :param content_type: the Content-Type for the request body
        :param is_multipart: whether this is a multipart request
        :return: map of header names to values
        """
        headers: Dict[str, str] = {}

        accept_header = self._select_accept_header(accept)
        if accept_header is not None:
            headers['Accept'] = accept_header

        if not is_multipart:
            if not content_type:
                content_type = 'application/json'
            headers['Content-Type'] = content_type

        return headers

    def _select_accept_header(self, accept: List[str]) -> Optional[str]:
        """Return the header 'Accept' based on an array of Accept provided.

        :param accept: Array of header
        :return: Accept (e.g. application/json)
        """
        if accept is None:
            return None

        # filter out empty entries
        filtered_accept = [s for s in accept if s is not None and s]

        if not filtered_accept:
            return None

        # If there's only one Accept header, just use it
        if len(filtered_accept) == 1:
            return filtered_accept[0]

        # If none of the available Accept headers is of type "json", then just use all them
        headers_with_json = self._select_json_mime_list(filtered_accept)
        if not headers_with_json:
            return ','.join(filtered_accept)

        # If we got here, then we need add quality values (weight), as described in IETF RFC 9110, Items 12.4.2/12.5.1,
        # to give the highest priority to json-like headers - recalculating the existing ones, if needed
        return self._get_accept_header_with_adjusted_weight(filtered_accept, headers_with_json)

    def is_json_mime(self, search_string: str) -> bool:
        """Detects whether a string contains a valid JSON mime type.

        :param search_string: the MIME type string to check
        :return: true if the string represents a JSON MIME type
        """
        if search_string is None:
            return False
        return self._JSON_MIME_PATTERN.search(search_string) is not None

    def _select_json_mime_list(self, mime_list: List[str]) -> List[str]:
        """Select all items from a list containing a JSON mime type.

        :param mime_list: list of MIME types to filter
        :return: list containing only JSON MIME types
        """
        return [mime for mime in mime_list if self.is_json_mime(mime)]

    def _get_accept_header_with_adjusted_weight(
        self,
        accept: List[str],
        headers_with_json: List[str]
    ) -> str:
        """Create an Accept header string from the given "Accept" headers array, recalculating all weights.

        :param accept: Array of Accept Headers
        :param headers_with_json: Array of Accept Headers of type "json"
        :return: "Accept" Header (e.g. "application/json, text/html; q=0.9")
        """
        with_application_json: List[Tuple[str, int]] = []
        with_json: List[Tuple[str, int]] = []
        without_json: List[Tuple[str, int]] = []

        for header in accept:
            header_data = self._get_header_and_weight(header)

            if header_data[0].lower().startswith('application/json'):
                with_application_json.append(header_data)
            elif header in headers_with_json:
                with_json.append(header_data)
            else:
                without_json.append(header_data)

        accept_headers: List[str] = []
        current_weight = [1000]

        has_more_than_28_headers = len(accept) > 28

        if with_application_json:
            accept_headers.extend(
                self._adjust_weight(with_application_json, current_weight, has_more_than_28_headers)
            )
        if with_json:
            accept_headers.extend(
                self._adjust_weight(with_json, current_weight, has_more_than_28_headers)
            )
        if without_json:
            accept_headers.extend(
                self._adjust_weight(without_json, current_weight, has_more_than_28_headers)
            )

        return ','.join(accept_headers)

    def _get_header_and_weight(self, header: str) -> Tuple[str, int]:
        """Given an Accept header, returns the header and its weight.

        :param header: "Accept" Header
        :return: tuple with the header and its weight
        """
        # matches headers with weight, splitting the header and the weight
        match = self._WEIGHT_PATTERN.match(header)
        if match:
            header_value = match.group(1)
            weight = float(match.group(2))
            return (header_value, int(weight * 1000))
        else:
            return (header.strip(), 1000)

    def _adjust_weight(
        self,
        headers: List[Tuple[str, int]],
        current_weight: List[int],
        has_more_than_28_headers: bool
    ) -> List[str]:
        """Adjust weights for a group of headers.

        :param headers: list of headers to process
        :param current_weight: list containing current weight (modified in place)
        :param has_more_than_28_headers: whether there are more than 28 total headers
        :return: array of adjusted "Accept" headers
        """
        headers.sort(key=lambda x: x[1], reverse=True)

        accept_headers: List[str] = []
        for index, (header, weight) in enumerate(headers):
            if index > 0 and headers[index - 1][1] > weight:
                current_weight[0] = self.get_next_weight(current_weight[0], has_more_than_28_headers)

            accept_headers.append(self._build_accept_header(header, current_weight[0]))

        current_weight[0] = self.get_next_weight(current_weight[0], has_more_than_28_headers)

        return accept_headers

    def _build_accept_header(self, header: str, weight: int) -> str:
        """Build a single Accept header string with optional quality weight.

        :param header: the MIME type
        :param weight: the quality weight (scaled by 1000)
        :return: formatted header string
        """
        if weight == 1000:
            return header

        clean_header = header.rstrip('; ')
        weight_str = f'{weight / 1000:.3f}'.rstrip('0').rstrip('.')

        return f'{clean_header};q={weight_str}'

    def get_next_weight(self, current_weight: int, has_more_than_28_headers: bool) -> int:
        """Calculate the next weight, based on the current one.

        If there are less than 28 "Accept" headers, the weights will be decreased by 1 on its highest significant digit, using the
        following formula:

           next weight = current weight - 10 ^ (floor(log(current weight - 1)))

           ( current weight minus ( 10 raised to the power of ( floor of (log to the base 10 of ( current weight minus 1 ) ) ) ) )

        Starting from 1000, this generates the following series:

        1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1

        The resulting quality codes are closer to the average "normal" usage of them (like "q=0.9", "q=0.8" and so on), but it only works
        if there is a maximum of 28 "Accept" headers. If we have more than that (which is extremely unlikely), then we fall back to a 1-by-1
        decrement rule, which will result in quality codes like "q=0.999", "q=0.998" etc.

        :param current_weight: varying from 1 to 1000 (will be divided by 1000 to build the quality value)
        :param has_more_than_28_headers: whether there are more than 28 headers
        :return: the next weight
        """
        if current_weight <= 1:
            return 1

        if has_more_than_28_headers:
            return current_weight - 1

        return current_weight - int(math.pow(10, math.floor(math.log10(current_weight - 1))))
