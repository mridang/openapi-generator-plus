=begin
#Swagger Petstore - OpenAPI 3.0

#A simplified Pet Store API for integration testing.

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
Generator version: 7.14.0

=end

=begin
NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
https://openapi-generator.tech
Do not edit the class manually.
=end

module OpigenClient
  # HeaderSelector
  class HeaderSelector
    JSON_MIME_PATTERN = /^application\/(json|[\w!#$&.+\-^_]+\+json)\s*(;|$)/i
    WEIGHT_PATTERN = /(.*)\s*;\s*q=(1(?:\.0+)?|0\.\d+)$/

    # Select headers for an API request.
    #
    # @param accept [Array<String>] array of acceptable MIME types for the response
    # @param content_type [String] the Content-Type for the request body
    # @param is_multipart [Boolean] whether this is a multipart request
    # @return [Hash<String, String>] map of header names to values
    def select_headers(accept, content_type, is_multipart)
      headers = {}

      accept_header = select_accept_header(accept)
      headers['Accept'] = accept_header unless accept_header.nil?

      unless is_multipart
        content_type = 'application/json' if content_type.nil? || content_type.empty?
        headers['Content-Type'] = content_type
      end

      headers
    end

    # Return the header 'Accept' based on an array of Accept provided.
    #
    # @param accept [Array<String>] Array of header
    # @return [String, nil] Accept (e.g. application/json)
    def select_accept_header(accept)
      return nil if accept.nil?

      # filter out empty entries
      filtered_accept = accept.reject { |s| s.nil? || s.empty? }

      return nil if filtered_accept.empty?

      # If there's only one Accept header, just use it
      return filtered_accept.first if filtered_accept.length == 1

      # If none of the available Accept headers is of type "json", then just use all them
      headers_with_json = select_json_mime_list(filtered_accept)
      return filtered_accept.join(',') if headers_with_json.empty?

      # If we got here, then we need add quality values (weight), as described in IETF RFC 9110, Items 12.4.2/12.5.1,
      # to give the highest priority to json-like headers - recalculating the existing ones, if needed
      get_accept_header_with_adjusted_weight(filtered_accept, headers_with_json)
    end

    # Detects whether a string contains a valid JSON mime type.
    #
    # @param search_string [String] the MIME type string to check
    # @return [Boolean] true if the string represents a JSON MIME type
    def is_json_mime(search_string)
      return false if search_string.nil?
      !!(search_string =~ JSON_MIME_PATTERN)
    end

    # Select all items from a list containing a JSON mime type.
    #
    # @param mime_list [Array<String>] list of MIME types to filter
    # @return [Array<String>] list containing only JSON MIME types
    def select_json_mime_list(mime_list)
      mime_list.select { |mime| is_json_mime(mime) }
    end

    # Create an Accept header string from the given "Accept" headers array, recalculating all weights.
    #
    # @param accept [Array<String>] Array of Accept Headers
    # @param headers_with_json [Array<String>] Array of Accept Headers of type "json"
    # @return [String] "Accept" Header (e.g. "application/json, text/html; q=0.9")
    def get_accept_header_with_adjusted_weight(accept, headers_with_json)
      with_application_json = []
      with_json = []
      without_json = []

      accept.each do |header|
        header_data = get_header_and_weight(header)

        if header_data[:header].downcase.start_with?('application/json')
          with_application_json << header_data
        elsif headers_with_json.include?(header)
          with_json << header_data
        else
          without_json << header_data
        end
      end

      accept_headers = []
      current_weight = { value: 1000 }

      has_more_than_28_headers = accept.length > 28

      accept_headers.concat(adjust_weight(with_application_json, current_weight, has_more_than_28_headers)) unless with_application_json.empty?
      accept_headers.concat(adjust_weight(with_json, current_weight, has_more_than_28_headers)) unless with_json.empty?
      accept_headers.concat(adjust_weight(without_json, current_weight, has_more_than_28_headers)) unless without_json.empty?

      accept_headers.join(',')
    end

    # Given an Accept header, returns the header and its weight.
    #
    # @param header [String] "Accept" Header
    # @return [Hash] hash with the header and its weight
    def get_header_and_weight(header)
      # matches headers with weight, splitting the header and the weight
      match = header.match(WEIGHT_PATTERN)
      if match
        {
          header: match[1],
          weight: (match[2].to_f * 1000).to_i
        }
      else
        {
          header: header.strip,
          weight: 1000
        }
      end
    end

    # Adjust weights for a group of headers.
    #
    # @param headers [Array<Hash>] list of headers to process
    # @param current_weight [Hash] hash containing current weight (modified in place)
    # @param has_more_than_28_headers [Boolean] whether there are more than 28 total headers
    # @return [Array<String>] array of adjusted "Accept" headers
    def adjust_weight(headers, current_weight, has_more_than_28_headers)
      headers.sort_by! { |h| -h[:weight] }

      accept_headers = []
      headers.each_with_index do |header, index|
        if index > 0 && headers[index - 1][:weight] > header[:weight]
          current_weight[:value] = get_next_weight(current_weight[:value], has_more_than_28_headers)
        end

        accept_headers << build_accept_header(header[:header], current_weight[:value])
      end

      current_weight[:value] = get_next_weight(current_weight[:value], has_more_than_28_headers)

      accept_headers
    end

    # Build a single Accept header string with optional quality weight.
    #
    # @param header [String] the MIME type
    # @param weight [Integer] the quality weight (scaled by 1000)
    # @return [String] formatted header string
    def build_accept_header(header, weight)
      return header if weight == 1000

      clean_header = header.gsub(/[;\s]+$/, '')
      weight_str = format('%.3f', weight / 1000.0).sub(/0+$/, '').sub(/\.$/, '')

      "#{clean_header};q=#{weight_str}"
    end

    # Calculate the next weight, based on the current one.
    #
    # If there are less than 28 "Accept" headers, the weights will be decreased by 1 on its highest significant digit, using the
    # following formula:
    #
    #    next weight = current weight - 10 ^ (floor(log(current weight - 1)))
    #
    #    ( current weight minus ( 10 raised to the power of ( floor of (log to the base 10 of ( current weight minus 1 ) ) ) ) )
    #
    # Starting from 1000, this generates the following series:
    #
    # 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
    #
    # The resulting quality codes are closer to the average "normal" usage of them (like "q=0.9", "q=0.8" and so on), but it only works
    # if there is a maximum of 28 "Accept" headers. If we have more than that (which is extremely unlikely), then we fall back to a 1-by-1
    # decrement rule, which will result in quality codes like "q=0.999", "q=0.998" etc.
    #
    # @param current_weight [Integer] varying from 1 to 1000 (will be divided by 1000 to build the quality value)
    # @param has_more_than_28_headers [Boolean] whether there are more than 28 headers
    # @return [Integer] the next weight
    def get_next_weight(current_weight, has_more_than_28_headers)
      return 1 if current_weight <= 1

      return current_weight - 1 if has_more_than_28_headers

      current_weight - (10 ** Math.log10(current_weight - 1).floor)
    end

    private :select_accept_header, :select_json_mime_list, :get_accept_header_with_adjusted_weight, :get_header_and_weight, :adjust_weight, :build_accept_header
  end
end
