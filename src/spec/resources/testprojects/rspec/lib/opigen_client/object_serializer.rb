=begin
#Swagger Petstore - OpenAPI 3.0

#A simplified Pet Store API for integration testing.

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
Generator version: 7.14.0

=end

require 'date'
require 'json'
require 'time'

begin
  require 'oj'
  OJ_AVAILABLE = true
rescue LoadError
  OJ_AVAILABLE = false
end

module OpigenClient
  # Exception raised when serialization or deserialization fails.
  #
  # @attr_reader [String] message The error message
  # @attr_reader [Exception, nil] cause The underlying exception that caused this error
  class SerializationError < StandardError
    attr_reader :cause

    # Creates a new SerializationError.
    #
    # @param message [String] The error message
    # @param cause [Exception, nil] The underlying exception
    def initialize(message, cause = nil)
      super(message)
      @cause = cause
    end
  end

  # Handles JSON serialization and deserialization for API requests and responses.
  #
  # This class provides a consistent interface for converting between Ruby objects
  # and JSON strings. It uses the Oj gem for fast JSON processing when available,
  # falling back to the standard JSON library otherwise.
  #
  # The serializer is configured with the following default settings:
  # - DateTime values are serialized in ISO8601 format
  # - Null/nil values are omitted from serialized output
  # - Model objects use their to_hash method for serialization
  # - Deserialization uses the model's build_from_hash class method
  #
  # @example Basic usage
  #   serializer = ObjectSerializer.new
  #   pet = Pet.new(id: 1, name: 'Fido', status: 'available')
  #   json_str = serializer.serialize(pet)
  #   restored_pet = serializer.deserialize(json_str, 'Pet')
  #
  class ObjectSerializer
    # Default format for DateTime serialization (ISO8601)
    DEFAULT_DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S%z'.freeze

    # @return [String] The datetime format string used for serialization
    attr_reader :datetime_format

    # Creates a new ObjectSerializer with the specified configuration.
    #
    # @param options [Hash] Configuration options
    # @option options [String] :datetime_format The format string for DateTime serialization.
    #   Defaults to ISO8601 format with timezone offset.
    def initialize(options = {})
      @datetime_format = options[:datetime_format] || DEFAULT_DATETIME_FORMAT
    end

    # Serialize an object to a JSON string.
    #
    # Handles all types supported by the OpenAPI specification including:
    # - Primitive types (String, Integer, Float, Boolean)
    # - DateTime and Date objects (formatted using configured format)
    # - Model objects (using to_hash method)
    # - Arrays and Hashes (recursively serialized)
    #
    # @param object [Object] The object to serialize. Can be nil.
    # @return [String] A JSON string representation of the object, or "null" if object is nil.
    # @raise [SerializationError] If serialization fails due to an unsupported type
    #   or JSON encoding error.
    def serialize(object)
      sanitized = sanitize_for_serialization(object)
      if OJ_AVAILABLE
        Oj.dump(sanitized, mode: :compat, time_format: :ruby)
      else
        JSON.generate(sanitized)
      end
    rescue => e
      raise SerializationError.new("Failed to serialize object to JSON: #{e.message}", e)
    end

    # Deserialize a JSON string to an object of the specified type.
    #
    # Handles all types supported by the OpenAPI specification including:
    # - Primitive types (String, Integer, Float, Boolean)
    # - DateTime and Date objects
    # - Model objects (using build_from_hash class method)
    # - Arrays (use "Array<ClassName>" syntax)
    # - Hashes (use "Hash<String, ClassName>" syntax)
    #
    # @param json_string [String, nil] The JSON string to deserialize. Can be nil or empty.
    # @param target_type [String] The target type as a string. Use "Array<Pet>" for arrays,
    #   "Hash<String, Pet>" for hashes.
    # @return [Object, nil] The deserialized object, or nil if json_string is nil or empty.
    # @raise [SerializationError] If deserialization fails due to invalid JSON,
    #   type mismatch, or unsupported type.
    def deserialize(json_string, target_type)
      return nil if json_string.nil? || json_string.empty?

      data = if OJ_AVAILABLE
               Oj.load(json_string, symbol_keys: true, mode: :compat)
             else
               JSON.parse(json_string, symbolize_names: true)
             end

      convert_to_type(data, target_type)
    rescue JSON::ParserError, Oj::ParseError => e
      raise SerializationError.new("Failed to parse JSON: #{e.message}", e)
    rescue => e
      raise SerializationError.new("Failed to deserialize JSON to #{target_type}: #{e.message}", e)
    end

    private

    # Sanitize an object for JSON serialization.
    #
    # @param object [Object] The object to sanitize
    # @return [Object] A JSON-serializable representation of the object
    def sanitize_for_serialization(object)
      case object
      when nil
        nil
      when String, Integer, Float, TrueClass, FalseClass
        object
      when Array
        object.map { |item| sanitize_for_serialization(item) }
      when Hash
        object.each_with_object({}) do |(key, value), hash|
          hash[key] = sanitize_for_serialization(value)
        end
      when Date
        object.to_s
      when Time, DateTime
        object.strftime(@datetime_format)
      else
        if object.respond_to?(:to_hash)
          sanitize_for_serialization(object.to_hash)
        elsif object.respond_to?(:to_json)
          object
        else
          object.to_s
        end
      end
    end

    # Convert data to the given return type.
    #
    # @param data [Object] Data to be converted
    # @param return_type [String] Return type
    # @return [Object] Data converted to the specified type
    def convert_to_type(data, return_type)
      return nil if data.nil?

      case return_type
      when 'String'
        data.to_s
      when 'Integer'
        data.to_i
      when 'Float'
        data.to_f
      when 'Boolean'
        data == true
      when 'Time'
        Time.parse(data.to_s)
      when 'Date'
        Date.parse(data.to_s)
      when 'Object'
        data
      when /\AArray<(.+)>\z/
        sub_type = $1
        data.map { |item| convert_to_type(item, sub_type) }
      when /\AHash<String, (.+)>\z/
        sub_type = $1
        data.each_with_object({}) do |(key, value), hash|
          hash[key] = convert_to_type(value, sub_type)
        end
      else
        # Model class (e.g. Pet, Order)
        klass = OpigenClient.const_get(return_type)
        if klass.respond_to?(:openapi_one_of)
          klass.build(data)
        elsif klass.respond_to?(:build_from_hash)
          klass.build_from_hash(data)
        else
          klass.new(data)
        end
      end
    end
  end
end
