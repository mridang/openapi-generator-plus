/*
 * Swagger Petstore - OpenAPI 3.0
 * A simplified Pet Store API for integration testing.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.example.petstore;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.util.StdDateFormat;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.openapitools.jackson.nullable.JsonNullableModule;

/**
 * Handles JSON serialization and deserialization for API requests and responses.
 *
 * <p>This class uses Jackson for all JSON processing with RFC3339 DateTime formatting.
 * It provides a consistent interface for converting between Java objects and JSON strings.</p>
 *
 * <p>The ObjectMapper is configured with the following settings:</p>
 * <ul>
 *   <li>Excludes null values from serialization</li>
 *   <li>Ignores unknown properties during deserialization</li>
 *   <li>Uses ISO8601/RFC3339 format for dates (not timestamps)</li>
 *   <li>Serializes/deserializes enums using their toString() values</li>
 * </ul>
 *
 * @see ObjectMapper
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ObjectSerializer {

    private final ObjectMapper objectMapper;

    /**
     * Creates a new ObjectSerializer with default configuration.
     *
     * <p>The default ObjectMapper is configured with:</p>
     * <ul>
     *   <li>NON_NULL inclusion (null values are omitted)</li>
     *   <li>Fail on unknown properties disabled</li>
     *   <li>Fail on invalid subtype disabled</li>
     *   <li>Write dates as ISO-8601 strings, not timestamps</li>
     *   <li>JavaTimeModule for Java 8+ date/time support</li>
     *   <li>JsonNullableModule for optional field handling</li>
     * </ul>
     */
    public ObjectSerializer() {
        this.objectMapper = createDefaultObjectMapper();
    }

    /**
     * Creates a new ObjectSerializer with a custom ObjectMapper.
     *
     * <p>Use this constructor when you need custom serialization settings.</p>
     *
     * @param objectMapper the ObjectMapper to use for serialization
     * @throws IllegalArgumentException if objectMapper is null
     */
    public ObjectSerializer(ObjectMapper objectMapper) {
        if (objectMapper == null) {
            throw new IllegalArgumentException("ObjectMapper cannot be null");
        }
        this.objectMapper = objectMapper;
    }

    /**
     * Serializes an object to a JSON string.
     *
     * <p>Handles all types supported by Jackson including:</p>
     * <ul>
     *   <li>Primitive types and their wrappers</li>
     *   <li>Java 8 date/time types (OffsetDateTime, LocalDate, etc.)</li>
     *   <li>Collections and arrays</li>
     *   <li>Nested objects (POJOs)</li>
     *   <li>Maps</li>
     * </ul>
     *
     * @param object the object to serialize (may be null)
     * @return JSON string representation, or "null" if object is null
     * @throws SerializationException if serialization fails
     */
    public String serialize(Object object) throws SerializationException {
        try {
            return objectMapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            throw new SerializationException("Failed to serialize object to JSON", e);
        }
    }

    /**
     * Deserializes a JSON string to an object of the specified type.
     *
     * <p>Use this method when you need to deserialize to a generic type like
     * {@code List<Pet>} or {@code Map<String, Object>}.</p>
     *
     * @param <T> the type to deserialize to
     * @param jsonString the JSON string to deserialize (may be null or empty)
     * @param typeReference the type reference for the target type
     * @return the deserialized object, or null if jsonString is null or empty
     * @throws SerializationException if deserialization fails
     */
    public <T> T deserialize(String jsonString, TypeReference<T> typeReference) throws SerializationException {
        if (jsonString == null || jsonString.isEmpty()) {
            return null;
        }
        try {
            return objectMapper.readValue(jsonString, typeReference);
        } catch (JsonProcessingException e) {
            throw new SerializationException("Failed to deserialize JSON to " + typeReference.getType(), e);
        }
    }

    /**
     * Deserializes a JSON string to an object of the specified class.
     *
     * <p>Use this method when deserializing to a simple (non-generic) type.</p>
     *
     * @param <T> the type to deserialize to
     * @param jsonString the JSON string to deserialize (may be null or empty)
     * @param targetClass the target class
     * @return the deserialized object, or null if jsonString is null or empty
     * @throws SerializationException if deserialization fails
     */
    public <T> T deserialize(String jsonString, Class<T> targetClass) throws SerializationException {
        if (jsonString == null || jsonString.isEmpty()) {
            return null;
        }
        try {
            return objectMapper.readValue(jsonString, targetClass);
        } catch (JsonProcessingException e) {
            throw new SerializationException("Failed to deserialize JSON to " + targetClass.getName(), e);
        }
    }

    /**
     * Gets the underlying ObjectMapper.
     *
     * <p>Use this method when you need direct access to the ObjectMapper for
     * advanced operations not covered by the serialize/deserialize methods.</p>
     *
     * @return the ObjectMapper instance (never null)
     */
    public ObjectMapper getObjectMapper() {
        return objectMapper;
    }

    /**
     * Creates the default ObjectMapper with standard configuration.
     *
     * @return a configured ObjectMapper instance
     */
    private static ObjectMapper createDefaultObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();

        // Serialization settings
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);

        // Deserialization settings
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false);
        mapper.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING);

        // Register modules for date/time and nullable handling
        mapper.registerModule(new JavaTimeModule());
        mapper.registerModule(new JsonNullableModule());

        // Use Jackson's standard ISO-8601 date format for legacy java.util.Date
        mapper.setDateFormat(new StdDateFormat().withColonInTimeZone(true));

        return mapper;
    }

    /**
     * Exception thrown when serialization or deserialization fails.
     */
    public static class SerializationException extends RuntimeException {

        /**
         * Creates a new SerializationException with the specified message and cause.
         *
         * @param message the detail message
         * @param cause the underlying cause
         */
        public SerializationException(String message, Throwable cause) {
            super(message, cause);
        }

        /**
         * Creates a new SerializationException with the specified message.
         *
         * @param message the detail message
         */
        public SerializationException(String message) {
            super(message);
        }
    }
}
