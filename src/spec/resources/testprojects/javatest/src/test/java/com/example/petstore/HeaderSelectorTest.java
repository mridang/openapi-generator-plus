/*
 * Swagger Petstore - OpenAPI 3.0
 * A simplified Pet Store API for integration testing.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.example.petstore;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for HeaderSelector.
 *
 * These tests verify RFC 9110 compliant content negotiation with quality weights.
 */
class HeaderSelectorTest {

    private HeaderSelector headerSelector;

    @BeforeEach
    void setUp() {
        headerSelector = new HeaderSelector();
    }

    @Nested
    @DisplayName("isJsonMime")
    class IsJsonMimeTests {

        @Test
        @DisplayName("should return true for application/json")
        void shouldReturnTrueForApplicationJson() {
            assertTrue(headerSelector.isJsonMime("application/json"));
        }

        @Test
        @DisplayName("should return true for application/json with charset")
        void shouldReturnTrueForApplicationJsonWithCharset() {
            assertTrue(headerSelector.isJsonMime("application/json; charset=UTF-8"));
        }

        @Test
        @DisplayName("should return true for APPLICATION/JSON (case insensitive)")
        void shouldReturnTrueForUppercaseApplicationJson() {
            assertTrue(headerSelector.isJsonMime("APPLICATION/JSON"));
        }

        @Test
        @DisplayName("should return true for vendor JSON types")
        void shouldReturnTrueForVendorJsonTypes() {
            assertTrue(headerSelector.isJsonMime("application/vnd.api+json"));
            assertTrue(headerSelector.isJsonMime("application/vnd.company+json"));
            assertTrue(headerSelector.isJsonMime("application/hal+json"));
        }

        @Test
        @DisplayName("should return false for text/html")
        void shouldReturnFalseForTextHtml() {
            assertFalse(headerSelector.isJsonMime("text/html"));
        }

        @Test
        @DisplayName("should return false for application/xml")
        void shouldReturnFalseForApplicationXml() {
            assertFalse(headerSelector.isJsonMime("application/xml"));
        }

        @Test
        @DisplayName("should return false for null")
        void shouldReturnFalseForNull() {
            assertFalse(headerSelector.isJsonMime(null));
        }

        @Test
        @DisplayName("should return false for empty string")
        void shouldReturnFalseForEmptyString() {
            assertFalse(headerSelector.isJsonMime(""));
        }
    }

    @Nested
    @DisplayName("selectHeaders")
    class SelectHeadersTests {

        @Test
        @DisplayName("should set Accept header when accepts provided")
        void shouldSetAcceptHeaderWhenAcceptsProvided() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json"},
                "application/json",
                false
            );
            assertEquals("application/json", headers.get("Accept"));
        }

        @Test
        @DisplayName("should not set Accept header when accepts empty")
        void shouldNotSetAcceptHeaderWhenAcceptsEmpty() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{},
                "application/json",
                false
            );
            assertNull(headers.get("Accept"));
        }

        @Test
        @DisplayName("should set Content-Type header when not multipart")
        void shouldSetContentTypeHeaderWhenNotMultipart() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json"},
                "application/json",
                false
            );
            assertEquals("application/json", headers.get("Content-Type"));
        }

        @Test
        @DisplayName("should not set Content-Type header when multipart")
        void shouldNotSetContentTypeHeaderWhenMultipart() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json"},
                "application/json",
                true
            );
            assertNull(headers.get("Content-Type"));
        }

        @Test
        @DisplayName("should default Content-Type to application/json when empty")
        void shouldDefaultContentTypeToApplicationJsonWhenEmpty() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json"},
                "",
                false
            );
            assertEquals("application/json", headers.get("Content-Type"));
        }

        @Test
        @DisplayName("should default Content-Type to application/json when null")
        void shouldDefaultContentTypeToApplicationJsonWhenNull() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json"},
                null,
                false
            );
            assertEquals("application/json", headers.get("Content-Type"));
        }

        @Test
        @DisplayName("should return single accept as-is")
        void shouldReturnSingleAcceptAsIs() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json"},
                "application/json",
                false
            );
            assertEquals("application/json", headers.get("Accept"));
        }

        @Test
        @DisplayName("should return single non-JSON accept as-is")
        void shouldReturnSingleNonJsonAcceptAsIs() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"text/html"},
                "application/json",
                false
            );
            assertEquals("text/html", headers.get("Accept"));
        }

        @Test
        @DisplayName("should return comma-separated list when no JSON types present")
        void shouldReturnCommaSeparatedListWhenNoJsonTypes() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"text/html", "text/plain"},
                "application/json",
                false
            );
            assertEquals("text/html,text/plain", headers.get("Accept"));
        }

        @Test
        @DisplayName("should prioritize application/json with quality weight")
        void shouldPrioritizeApplicationJsonWithQualityWeight() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"text/html", "application/json"},
                "application/json",
                false
            );
            String accept = headers.get("Accept");
            // application/json should come first with highest weight
            assertTrue(accept.startsWith("application/json"));
            assertTrue(accept.contains("text/html"));
        }

        @Test
        @DisplayName("should handle multiple JSON types with priority")
        void shouldHandleMultipleJsonTypesWithPriority() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"text/html", "application/vnd.api+json", "application/json"},
                "application/json",
                false
            );
            String accept = headers.get("Accept");
            // application/json should come first
            assertTrue(accept.startsWith("application/json"));
            // application/vnd.api+json should come before text/html
            int jsonIndex = accept.indexOf("application/json");
            int vendorJsonIndex = accept.indexOf("application/vnd.api+json");
            int htmlIndex = accept.indexOf("text/html");
            assertTrue(jsonIndex < vendorJsonIndex);
            assertTrue(vendorJsonIndex < htmlIndex);
        }

        @Test
        @DisplayName("should filter out empty entries")
        void shouldFilterOutEmptyEntries() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"", "application/json", null},
                "application/json",
                false
            );
            assertEquals("application/json", headers.get("Accept"));
        }

        @Test
        @DisplayName("should preserve existing quality weights in order")
        void shouldPreserveExistingQualityWeightsInOrder() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"text/html;q=0.9", "application/json", "text/plain;q=0.8"},
                "application/json",
                false
            );
            String accept = headers.get("Accept");
            // application/json should still come first (JSON priority)
            assertTrue(accept.startsWith("application/json"));
        }
    }

    @Nested
    @DisplayName("getNextWeight")
    class GetNextWeightTests {

        @Test
        @DisplayName("should return standard weight sequence for <= 28 headers")
        void shouldReturnStandardWeightSequence() {
            // Starting from 1000, should get: 1000, 900, 800, 700, ...
            assertEquals(900, headerSelector.getNextWeight(1000, false));
            assertEquals(800, headerSelector.getNextWeight(900, false));
            assertEquals(700, headerSelector.getNextWeight(800, false));
            assertEquals(600, headerSelector.getNextWeight(700, false));
            assertEquals(500, headerSelector.getNextWeight(600, false));
            assertEquals(400, headerSelector.getNextWeight(500, false));
            assertEquals(300, headerSelector.getNextWeight(400, false));
            assertEquals(200, headerSelector.getNextWeight(300, false));
            assertEquals(100, headerSelector.getNextWeight(200, false));
            // After 100, goes to 90, 80, ...
            assertEquals(90, headerSelector.getNextWeight(100, false));
            assertEquals(80, headerSelector.getNextWeight(90, false));
        }

        @Test
        @DisplayName("should return 1-by-1 decrement for > 28 headers")
        void shouldReturnOneByOneDecrementForMoreThan28Headers() {
            assertEquals(999, headerSelector.getNextWeight(1000, true));
            assertEquals(998, headerSelector.getNextWeight(999, true));
            assertEquals(997, headerSelector.getNextWeight(998, true));
        }

        @Test
        @DisplayName("should return 1 when weight is 1 or less")
        void shouldReturnOneWhenWeightIsOneOrLess() {
            assertEquals(1, headerSelector.getNextWeight(1, false));
            assertEquals(1, headerSelector.getNextWeight(0, false));
            assertEquals(1, headerSelector.getNextWeight(-1, false));
        }

        @Test
        @DisplayName("should produce exactly 27 steps")
        void shouldProduceExactly27Steps() {
            // The formula should produce exactly 27 steps from 1000 to 1
            int weight = 1000;
            int count = 0;
            while (weight > 1) {
                weight = headerSelector.getNextWeight(weight, false);
                count++;
            }
            // 1000 -> 900 -> 800 -> ... -> 100 -> 90 -> ... -> 10 -> 9 -> ... -> 1
            // That's 9 (1000 to 100) + 9 (100 to 10) + 9 (10 to 1) = 27 steps
            assertEquals(27, count);
        }
    }

    @Nested
    @DisplayName("Quality weight formatting")
    class QualityWeightFormattingTests {

        @Test
        @DisplayName("should not add quality weight for weight 1000")
        void shouldNotAddQualityWeightForWeight1000() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json", "text/html"},
                "application/json",
                false
            );
            String accept = headers.get("Accept");
            // First header should not have ;q= because it's weight 1000
            assertTrue(accept.startsWith("application/json,") || accept.equals("application/json"));
        }

        @Test
        @DisplayName("should format quality weight correctly")
        void shouldFormatQualityWeightCorrectly() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json", "text/html"},
                "application/json",
                false
            );
            String accept = headers.get("Accept");
            // text/html should have quality weight like ;q=0.9
            assertTrue(accept.contains("text/html;q=0.9") || accept.contains("text/html;q=0."));
        }

        @Test
        @DisplayName("should remove trailing zeros from quality weight")
        void shouldRemoveTrailingZerosFromQualityWeight() {
            Map<String, String> headers = headerSelector.selectHeaders(
                new String[]{"application/json", "text/html"},
                "application/json",
                false
            );
            String accept = headers.get("Accept");
            // Should be ;q=0.9 not ;q=0.900
            assertFalse(accept.contains(";q=0.900"));
        }
    }
}
